# 4.15
问题：有5只猴子在海边发现一堆桃子,决定第二天来平分.第二天清晨,第一只猴子最早来到,它左分右分分不开,就朝海里扔了一只,恰好可以分成5份,
它拿上自己的一份走了.第2,3,4,5只猴子也遇到同样的问题,采用了同样的方法,都是扔掉一只后,恰好可以分成5份.问这堆桃子至少有多少只？

***这应该是一道比较经典的题目（据说是李政道先生在中科大少年班提出的题目），昨晚看见这题思考了很久，有了自己一点见解。***

思考过程：
    首先给了规则（桃子的分配方法），有下界（ 一个自然数域的下界是123456789......，很明显能感觉到，在此规则下，自然数集的某一个集合是
    满足这样的条件的，也就是说如果有第六只猴子，那么它一定能平均分配或者不满足丢掉一个后能均分），那么一定有解的。
    
    解：
      首先想到的是既然每次分配都要多于一个出来，那么设桃子总数为X,令总数为X+4(为什么这样设，仔细想想应该明白，每次分配都多于一个，所以
      在总数的基础上加一个4，所有猴子都能均分）,此时第12345只猴子都能平均分配，设5只猴子分别能分到的桃子依次为a,b,c,d,e,
      有：
        a = （（x+4）/5）     b = （(x+4)/5)*4/5 = 4*(x+4)/25    c = 16*(x+4)/125    d = 64*(x+4)/625    e = 256*(x+4)/3125
        
        a,b,c,d,e都是整数，现在研究 e 的表达式（为什么研究 e 不研究 其他字母？因为 e 是下界，只有一个x），x+4 为 3125 的整数倍，
        既：X+4 = 3125*n（n为自然数），解得最小的 n 为 3121.
        
        
***该算法是借鉴别人的，感觉很经典，加上一些自己的理解，C++算法已上传，改天再整个python版的****
